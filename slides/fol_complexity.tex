\begin{slide}[bm=,toc=]{Validity in FOL is Undecidable}
There is no decision procedure for validity in first order logic.
\begin{itemize}
\item<2-> First proved by Alonzo Church in 1936.
\item<3-> Proof uses a reduction \emph{from} the halting problem.
\item<4-> That is $\id{HALT} \leq \id{FOL-VAL}$
\begin{itemize}
\item<5-> The halting problem is proven to be undecidable.
\item<6-> Therefore, $\id{FOL-VAL}$ is undecidable.
\end{itemize}
\end{itemize}
\pause[6]
How the reduction works:
\begin{itemize}
\item<8-> Begins with an arbitrary Turing machine $T$.
\item<9-> Constructs a formula $S_T$ in first-order logic, such that
\begin{itemize}
\item<10-> $S_T$ is valid iff $T$ halts on a blank tape.
\end{itemize}
\item<11->This shows that a decision procedure for $\id{FOL-VAL}$ would also solve
the halting problem.
\end{itemize}
\end{slide}

\begin{wideslide}[bm=,toc=]{Church's Theorem}
\begin{thm}{12.3}[Church]

\emph{Validity in first-order logic is undecidable.}
\end{thm}
\pause
Holds even under the following restrictions:
\begin{enumerate}
\item<3-> The formulas contain only binary predicate symbols, one constant and one
unary function symbol.
\begin{itemize}
\item<3-> Ex: $\forall x (p(x,f(x)) \imp a$.
\end{itemize}
\item<4-> The formulas are logic programs.
\begin{itemize}
\item<4-> Restricted set of clauses structured to perform computations.
\item<4-> See Ben Ari chapter 11.
\end{itemize}
\item<5-> The formulas are pure (see below).
\end{enumerate}
\vspace{-2ex}
\pause[4]
\begin{defn}{12.4}[Ben Ari]
A formula of first-order logic is \emph{pure} if it contains no function symbols
(including constants which are 0-ary functions symbols).
\end{defn}
{\bf Note:} Validity is undecidable \emph{with} or \emph{without} function symbols.
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Additional Implications of Church's Theorem}
{\bf Recall:}\\
A formula is valid if and only if its complement (negation) is unsatisfiable.
\begin{itemize}
\item<2-> There is a simple reduction from a formula to its complement (negation).
\item<3-> Therefore, $\id{FOL-VAL} \leq \id{FOL-UNSAT}$ 
\item<4-> $\id{FOL-VAL}$ is undecidable.
\item<5-> Therefore, $\id{FOL-UNSAT}$ is undecidable.
\end{itemize}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Semi-decision Procedures for FOL-UNSAT}
\begin{itemize}
\item<2-> Resolution for FOL is a semi-decision procedure (Robinson) for FOL-UNSAT.
\item<3-> Another technique, constructing a \emph{semantic tableau} is also
semi-decision procedure.
\item<4-> Thus, $\id{FOL-UNSAT}$ is semi-decidable.
\item<5-> Since $\id{FOL-VAL} \leq \id{FOL-UNSAT}$ 
\item<6-> $\id{FOL-VAL}$ is semi-decidable. 
\end{itemize}
\pause[6]
{\bf Recall:} 
\begin{itemize}
\item<8-> $\id{FOL-SAT}$ = $\id{FOL}$ - $\id{FOL-UNSAT}$
\item<9-> Properties of semi-decision procedures:
\begin{itemize}
\item<10-> Return ``yes'' if an element is in the target set.
\item<11-> Return ``no'' or runs forever if not.
\end{itemize}
\item<12->  Therefore, $\id{FOL-SAT}$ is \emph{neither} decidable \emph{nor}
semi-decidable.
\end{itemize}

\end{wideslide}

\begin{wideslide}[bm=,toc=]{Satisfiability vs Validity in PL and FOL}
In propositional logic:
\begin{itemize}
\item<2-> $\id{SAT}$ is NP-complete $\imp \id{UNSAT}$ is $\id{CoNP}$-complete. 
\item<3-> $\id{UNSAT} \leq_p \id{VAL}$, so $\id{VAL}$ is $\id{CoNP}$-Hard.
\item<4-> $\id{INVAL}$ is in NP $\imp \id{VAL}$ is in $\id{CoNP}$.
\item<5-> $\id{VAL}$ is in CoNP and $\id{VAL}$ is $\id{CoNP}$-Hard $\imp \id{VAL}$ is $\id{CoNP}$
complete.
\item<6-> Therefore, in PL, $\id{VAL}$ is harder than $\id{SAT}$ unless $\id{NP} = \id{CoNP}$.
\end{itemize}
In first-order logic:
\begin{itemize}
\item<7-> $\id{VAL} \leq_p \id{UNSAT}$
\begin{itemize}
\item<8-> $\id{VAL}$ is undecidable $\imp \id{UNSAT}$ is undecidable. 
\item<9-> $\id{UNSAT}$ is semi-decidable $\imp \id{VAL}$ is semi-decidable. 
\end{itemize}
\item<10-> $\id{UNSAT}$ is semi-decidable $\imp \id{SAT}$ \emph{not} semi-decidable. 
\item<11-> Therefore, in FOL, $\id{SAT}$ is harder than $\id{VAL}$.
\end{itemize}
\end{wideslide}


