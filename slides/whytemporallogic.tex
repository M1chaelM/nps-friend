\documentclass[style=sailor,size=12pt]{powerdot}
\usepackage{epic,array,ecltree,url,calrsfs}
\usepackage[nointegrals]{wasysym}
\usepackage{listings}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsxtra}
\usepackage{amsthm}
\usepackage{mlextra} % Must be below ams packages
\usepackage{mathrsfs}
\usepackage{color}
\usepackage{array}
\usepackage{graphicx}
\graphicspath{ {../art/} }
\usepackage{bm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{enumitem}


\pdsetup{method=normal}

\title{Why Temporal Logic?}
\author{Foundations of Computer Science}
\date{\today}

\pdsetup{method=normal}

\begin{document}
\maketitle


\begin{wideslide}[bm=,toc=]{Policies in first-order logic}
\begin{itemize}
\item Recall the policy:
\begin{displaymath}
\begin{array}{l}
\forall i\, \forall t\, \forall a\, ((\bid{PaidFee}(i,t)\wedge (\bid{now} - 6 < t < \bid{now})\wedge \\
\bid{Customer}(i,\bid{now})\wedge\bid{Article}(a) \Rightarrow \bid{Permitted}(i,\rid{download}(a)))
\end{array}
\end{displaymath}
%$\bid{now}$ is a constant denoting current time 
\item {\bf Customer} is parameterized on time.
\item Its truth varies across time (dynamic truth).
\item Contrast with {\bf Article} whose truth is static.
\item A more natural way to express this policy uses {\em temporal logic\/}.
\end{itemize}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{center}
\begin{picture}(255,50)
%\begin{picture}(255,25)
\put(  -15, -20){\makebox(2,12){\small time:}}
\put(  0, 0){\state{\tinysz{n=0}}{$s_{0}$}}
\put(  10, -20){\makebox(2,12){\small $t_0$}}
\put( 20,10){\vector(1,0){40}}
\put( 60, 0){\state{\tinysz{n=1}}{$s_{1}$}}
\put(  70, -20){\makebox(2,12){\small $t_1$}}
\put( 80,10){\vector(1,0){40}}
\put(120, 0){\state{\tinysz{n=2}}{$s_{2}$}}
\put( 130, -20){\makebox(2,12){\small $t_2$}}
\put(140,10){\vector(1,0){40}}
\put(180, 0){\state{\tinysz{n=3}}{$s_{3}$}}
\put( 198, -20){\makebox(2,12){\small $t_3\ldots$}}
%\put(200,10){\vector(1,0){40}}
%\put(245,5){\makebox(10,10){$\cdots$}}
	\put(190,0){\line(0,-1){3}}
	\put(202,-2){\oval(24,12)[b]}
	\put(202,-2){\oval(24,12)[tr]}
	\put(203,4){\vector(-1,0){5}}
	%\put(70,0){\line(0,-1){3}}
	%\put(82,-2){\oval(24,12)[b]}
	%\put(82,-2){\oval(24,12)[tr]}
	%\put(83,4){\vector(-1,0){5}}
\end{picture}
\end{center}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{displaymath}
\begin{array}{|l|l|}
\hline
\bid{First-order logic} & \bid{Temporal logic analog} \\\hline
\forall i\geq 0.\, n=_{t_i}2\;\rid{is False} & s_0\not\models\Box n = 2\\\hline
\exists i\geq 0.\, n=_{t_i}2\;\rid{is True}  & s_0\models\Diamond n = 2\\\hline
\forall i.\exists j.\, n=_{t_j}3 \wedge j\geq i\;\rid{is True} & s_0\models\Box\Diamond n = 3\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i > j\;\rid{is False} & 
s_0\not\models\Diamond (n = 3\wedge\Diamond n = 2)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i < j\;\rid{is True} & 
s_0\models\Diamond (n = 2\wedge\Diamond n = 3)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3\;\rid{is True} & 
\rid{no temporal analog as it} \\
 & \rid{must order}\;t_i\;\rid{and}\;t_j\\\hline
\end{array}
\end{displaymath}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{enumerate}
\item FOL doesn't care about temporal ordering.  Can write
\begin{displaymath}
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3
\end{displaymath}
which is true for the C program.
\item Says nothing about which predicate became true first.
\item Hence it has no analog in temporal logic.
\item Temporal logic cares about temporal ordering of events.
\item Awkward predicates in FOL as they're parameterized on time.
\item But time is not referenced anywhere in the C program.
\item Predicates not parametrized on time in temporal logic.
\end{enumerate}
\end{wideslide}
\end{document}
\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
For many objects of study in computer science we model behavior as a function of
time.
\begin{itemize}
\item Clock cycles in hardware.
\item Steps of execution in software.
\end{itemize}

\begin{ex}{: C Program}[]
\end{ex}
\vspace{-6ex}
\begin{program}
for (n = 0; n < 3; n++)\\
\>\>;
\end{program}

\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{center}
\begin{picture}(255,50)
%\begin{picture}(255,25)
\put(  -15, -20){\makebox(2,12){\small time:}}
\put(  0, 0){\state{\tinysz{n=0}}{$s_{0}$}}
\put(  10, -20){\makebox(2,12){\small $t_0$}}
\put( 20,10){\vector(1,0){40}}
\put( 60, 0){\state{\tinysz{n=1}}{$s_{1}$}}
\put(  70, -20){\makebox(2,12){\small $t_1$}}
\put( 80,10){\vector(1,0){40}}
\put(120, 0){\state{\tinysz{n=2}}{$s_{2}$}}
\put( 130, -20){\makebox(2,12){\small $t_2$}}
\put(140,10){\vector(1,0){40}}
\put(180, 0){\state{\tinysz{n=3}}{$s_{3}$}}
\put( 198, -20){\makebox(2,12){\small $t_3\ldots$}}
%\put(200,10){\vector(1,0){40}}
%\put(245,5){\makebox(10,10){$\cdots$}}
	\put(190,0){\line(0,-1){3}}
	\put(202,-2){\oval(24,12)[b]}
	\put(202,-2){\oval(24,12)[tr]}
	\put(203,4){\vector(-1,0){5}}
	%\put(70,0){\line(0,-1){3}}
	%\put(82,-2){\oval(24,12)[b]}
	%\put(82,-2){\oval(24,12)[tr]}
	%\put(83,4){\vector(-1,0){5}}
\end{picture}
\end{center}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{displaymath}
\begin{array}{|l|l|}
\hline
\bid{First-order logic} & \bid{Temporal logic analog} \\\hline
\forall i\geq 0.\, n=_{t_i}2\;\rid{is False} & s_0\not\models\Box n = 2\\\hline
\exists i\geq 0.\, n=_{t_i}2\;\rid{is True}  & s_0\models\Diamond n = 2\\\hline
\forall i.\exists j.\, n=_{t_j}3 \wedge j\geq i\;\rid{is True} & s_0\models\Box\Diamond n = 3\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i \geq j\;\rid{is False} & 
s_0\not\models\Diamond (n = 3\wedge\Diamond n = 2)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i \leq j\;\rid{is True} & 
s_0\models\Diamond (n = 2\wedge\Diamond n = 3)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3\;\rid{is True} & 
\rid{no temporal analog as it} \\
 & \rid{must order}\;t_i\;\rid{and}\;t_j\\\hline
\end{array}
\end{displaymath}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{enumerate}
\item FOL doesn't care about temporal ordering.  
\begin{itemize}
\item Can write
\begin{displaymath}
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3
\end{displaymath}
which is true for the C program.
\item Says nothing about which predicate became true first.
\item Hence it has no analog in temporal logic.
\end{itemize}
\item Predicates in FOL can be parameterized on time.
\begin{itemize}
\item Produces awkward constructions.
\item Time is not referenced anywhere in the C program.
\item Predicates not parametrized on time in temporal logic.
\end{itemize}
\item Temporal logic naturally expresses temporal ordering of events.
\end{enumerate}
\end{wideslide}
\end{document}
