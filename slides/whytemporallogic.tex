
\documentclass[style=sailor,size=12pt]{powerdot}
\usepackage{epic,array,ecltree,url,calrsfs}
\usepackage[nointegrals]{wasysym}
\usepackage{mlextra}
\usepackage{listings}
\graphicspath{ {../art/} }

\newcommand{\id}[1]{\mbox{\it #1\/}}
\newcommand{\rid}[1]{\mbox{\rm #1}}
\newcommand{\sid}[1]{\mbox{\sf #1}}
\newcommand{\bid}[1]{\mbox{\bf #1}}
\newcommand{\tinysz}[1]{\mbox{\tiny $#1$}}

\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsxtra}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{color}
\usepackage{array}
\usepackage{graphicx}
\graphicspath{ {../art/} }
\usepackage{bm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{enumitem}

\renewcommand\qedsymbol{$\blacksquare$}

%Here I define some theorem styles and shortcut commands for symbols I use often
\theoremstyle{definition}

\newtheorem{innerdefn}{Definition}
\newenvironment{defn}[1]
  {\renewcommand\theinnerdefn{#1}\innerdefn}
  {\endinnerdefn}

\newtheorem{innerexample}{Example}
\newenvironment{ex}[1]
  {\renewcommand\theinnerexample{#1}\innerexample}
  {\endinnerexample}

\newtheorem{innerthm}{Theorem}
\newenvironment{thm}[1]
  {\renewcommand\theinnerthm{#1}\innerthm}
  {\endinnerthm}

\newtheorem{innerlem}{Lemma}
\newenvironment{lem}[1]
  {\renewcommand\theinnerlem{#1}\innerlem}
  {\endinnerlem}

\newcommand{\lra}{\longrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\surj}{\twoheadrightarrow}
\newcommand{\graph}{\mathrm{graph}}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\Ell}{\mathscr{L}}
\newcommand{\Z}{\bb{Z}}
\newcommand{\Q}{\bb{Q}}
\newcommand{\R}{\bb{R}}
\newcommand{\C}{\bb{C}}
\newcommand{\N}{\bb{N}}
\newcommand{\M}{\mathbf{M}}
\newcommand{\m}{\mathbf{m}}
\newcommand{\MM}{\mathscr{M}}
\newcommand{\HH}{\mathscr{H}}
\newcommand{\Om}{\Omega}
\newcommand{\Ho}{\in\HH(\Om)}
\newcommand{\bd}{\partial}
\newcommand{\del}{\partial}
\newcommand{\bardel}{\overline\partial}
\newcommand{\textdf}[1]{\textbf{\textsf{#1}}\index{#1}}
\newcommand{\img}{\mathrm{img}}
\newcommand{\ip}[2]{\left\langle{#1},{#2}\right\rangle}
\newcommand{\inter}[1]{\mathrm{int}{#1}}
\newcommand{\exter}[1]{\mathrm{ext}{#1}}
\newcommand{\cl}[1]{\mathrm{cl}{#1}}
\newcommand{\ds}{\displaystyle}
\newcommand{\vol}{\mathrm{vol}}
\newcommand{\cnt}{\mathrm{ct}}
\newcommand{\osc}{\mathrm{osc}}
\newcommand{\LL}{\mathbf{L}}
\newcommand{\UU}{\mathbf{U}}
\newcommand{\support}{\mathrm{support}}
\newcommand{\AND}{\;\wedge\;}
\newcommand{\OR}{\;\vee\;}
\newcommand{\Oset}{\varnothing}
\newcommand{\st}{\ni}
\newcommand{\wh}{\widehat}
\newcommand{\mli}[1]{\mathit{#1}}
\newcommand{\ndiv}{\hspace{-3pt}\not|\hspace{2pt}}


\pdsetup{method=normal}

\title{Why Temporal Logic?}
\author{Foundations of Computer Science}
\date{\today}

\pdsetup{method=normal}

\begin{document}
\maketitle

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
For many objects of study in computer science we model behavior as a function of
time.
\begin{itemize}
\item Clock cycles in hardware.
\item Steps of execution in software.
\end{itemize}

\begin{ex}{: C Program}[]
\end{ex}
\vspace{-6ex}
\begin{program}
for (n = 0; n < 3; n++)\\
\>\>;
\end{program}

\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{center}
\begin{picture}(255,50)
%\begin{picture}(255,25)
\put(  -15, -20){\makebox(2,12){\small time:}}
\put(  0, 0){\state{\tinysz{n=0}}{$s_{0}$}}
\put(  10, -20){\makebox(2,12){\small $t_0$}}
\put( 20,10){\vector(1,0){40}}
\put( 60, 0){\state{\tinysz{n=1}}{$s_{1}$}}
\put(  70, -20){\makebox(2,12){\small $t_1$}}
\put( 80,10){\vector(1,0){40}}
\put(120, 0){\state{\tinysz{n=2}}{$s_{2}$}}
\put( 130, -20){\makebox(2,12){\small $t_2$}}
\put(140,10){\vector(1,0){40}}
\put(180, 0){\state{\tinysz{n=3}}{$s_{3}$}}
\put( 198, -20){\makebox(2,12){\small $t_3\ldots$}}
%\put(200,10){\vector(1,0){40}}
%\put(245,5){\makebox(10,10){$\cdots$}}
	\put(190,0){\line(0,-1){3}}
	\put(202,-2){\oval(24,12)[b]}
	\put(202,-2){\oval(24,12)[tr]}
	\put(203,4){\vector(-1,0){5}}
	%\put(70,0){\line(0,-1){3}}
	%\put(82,-2){\oval(24,12)[b]}
	%\put(82,-2){\oval(24,12)[tr]}
	%\put(83,4){\vector(-1,0){5}}
\end{picture}
\end{center}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{displaymath}
\begin{array}{|l|l|}
\hline
\bid{First-order logic} & \bid{Temporal logic analog} \\\hline
\forall i\geq 0.\, n=_{t_i}2\;\rid{is False} & s_0\not\models\Box n = 2\\\hline
\exists i\geq 0.\, n=_{t_i}2\;\rid{is True}  & s_0\models\Diamond n = 2\\\hline
\forall i.\exists j.\, n=_{t_j}3 \wedge j\geq i\;\rid{is True} & s_0\models\Box\Diamond n = 3\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i \geq j\;\rid{is False} & 
s_0\not\models\Diamond (n = 3\wedge\Diamond n = 2)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i \leq j\;\rid{is True} & 
s_0\models\Diamond (n = 2\wedge\Diamond n = 3)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3\;\rid{is True} & 
\rid{no temporal analog as it} \\
 & \rid{must order}\;t_i\;\rid{and}\;t_j\\\hline
\end{array}
\end{displaymath}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{enumerate}
\item FOL doesn't care about temporal ordering.  
\begin{itemize}
\item Can write
\begin{displaymath}
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3
\end{displaymath}
which is true for the C program.
\item Says nothing about which predicate became true first.
\item Hence it has no analog in temporal logic.
\end{itemize}
\item Predicates in FOL can be parameterized on time.
\begin{itemize}
\item Produces awkward constructions.
\item Time is not referenced anywhere in the C program.
\item Predicates not parametrized on time in temporal logic.
\end{itemize}
\item Temporal logic naturally expresses temporal ordering of events.
\end{enumerate}
\end{wideslide}
\end{document}
