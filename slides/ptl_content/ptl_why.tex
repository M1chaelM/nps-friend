\begin{wideslide}[bm=,toc=]{Policies in first-order logic}
\begin{itemize}
\item Recall the policy:
\begin{displaymath}
\begin{array}{l}
\forall i\, \forall t\, \forall a\, ((\bid{PaidFee}(i,t)\wedge (\bid{now} - 6 < t < \bid{now})\wedge \\
\bid{Customer}(i,\bid{now})\wedge\bid{Article}(a) \Rightarrow \bid{Permitted}(i,\rid{download}(a)))
\end{array}
\end{displaymath}
%$\bid{now}$ is a constant denoting current time 
\item {\bf Customer} is parameterized on time.
\item Its truth varies across time (dynamic truth).
\item Contrast with {\bf Article} whose truth is static.
\item A more natural way to express this policy uses {\em temporal logic\/}.
\end{itemize}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{ex}{C Program}
\end{ex}
\vspace{-10mm}
\begin{program}
for (n = 0; n < 4; n++)\\
\>\>;
\end{program}
\pause
\textbf{State at time t:}
\begin{center}
\begin{picture}(200,50)
%\begin{picture}(255,25)
\put(  -15, -20){\makebox(2,12){\small time:}}
\put(  0, 0){\state{\tinysz{n=0}}{$s_{0}$}}
\put(  10, -20){\makebox(2,12){\small $t_0$}}
\put( 20,10){\vector(1,0){40}}
\put( 60, 0){\state{\tinysz{n=1}}{$s_{1}$}}
\put(  70, -20){\makebox(2,12){\small $t_1$}}
\put( 80,10){\vector(1,0){40}}
\put(120, 0){\state{\tinysz{n=2}}{$s_{2}$}}
\put( 130, -20){\makebox(2,12){\small $t_2$}}
\put(140,10){\vector(1,0){40}}
\put(180, 0){\state{\tinysz{n=3}}{$s_{3}$}}
\put( 198, -20){\makebox(2,12){\small $t_3\ldots$}}
%\put(200,10){\vector(1,0){40}}
%\put(245,5){\makebox(10,10){$\cdots$}}
	\put(190,0){\line(0,-1){3}}
	\put(202,-2){\oval(24,12)[b]}
	\put(202,-2){\oval(24,12)[tr]}
	\put(203,4){\vector(-1,0){5}}
	%\put(70,0){\line(0,-1){3}}
	%\put(82,-2){\oval(24,12)[b]}
	%\put(82,-2){\oval(24,12)[tr]}
	%\put(83,4){\vector(-1,0){5}}
\end{picture}
\end{center}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{displaymath}
\begin{array}{|l|l|}
\hline
\bid{First-order logic} & \bid{Temporal logic analog} \\\hline
\forall i\geq 0.\, n=_{t_i}2\;\rid{is False} & s_0\not\models\Box n = 2\\\hline 
\exists i\geq 0.\, n=_{t_i}2\;\rid{is True}  & s_0\models\Diamond n = 2\\\hline
\forall i.\exists j.\, n=_{t_j}3 \wedge j\geq i\;\rid{is True} & s_0\models\Box\Diamond n = 3\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i \geq j\;\rid{is False} & 
s_0\not\models\Diamond (n = 3\wedge\Diamond n = 2)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3 \wedge i \leq j\;\rid{is True} & 
s_0\models\Diamond (n = 2\wedge\Diamond n = 3)\\\hline
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3\;\rid{is True} & 
\rid{no temporal analog as it} \\
 & \rid{must order}\;t_i\;\rid{and}\;t_j\\\hline
\end{array}
\end{displaymath}
\end{wideslide}

\begin{wideslide}[bm=,toc=]{Why Temporal Logic?}
\begin{enumerate}
\item<1-> FOL doesn't care about temporal ordering.  
\begin{itemize}
\item<2-> Can write
\begin{displaymath}
\exists i.\exists j.\, n =_{t_i}2 \wedge n=_{t_j}3
\end{displaymath}
which is true for the C program.
\item<2-> Says nothing about which predicate became true first.
\item<2-> Hence it has no analog in temporal logic.
\end{itemize}
\item<3-> Predicates in FOL can be parameterized on time.
\begin{itemize}
\item<4-> Produces awkward constructions.
\item<4-> Time is not referenced anywhere in the C program.
\item<4-> Predicates not parametrized on time in temporal logic.
\end{itemize}
\item<5-> Temporal logic naturally expresses temporal ordering of events.
\end{enumerate}
\end{wideslide}
